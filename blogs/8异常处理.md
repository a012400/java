# 异常处理

Java的异常处理机制主要依赖于try、catch、finally、throw和throws五个关键字，其中try关键字后紧跟一个花括号括起来的代码块（花括号不可省略），简称try块，它里面放置可能引发异常的代码。catch后对应异常类型和一个代码块，用于表明该catch块用于处理这种类型的代码块。多个catch后还可以跟一个finally块，finally块用于回收在try块里打开的物理资源，异常机制会保证finally块总被执行。throws关键字主要在方法签名中使用，用于声明该方法可能抛出的异常；而throw用于抛出一个实际的异常，throw可以单独作为语句使用，抛出一个具体的异常对象。

Java7进一步增强了异常处理机制的功能，包括带资源的try语句、捕获多异常的catch两个新功能。

Java将异常分为两种，**Checked异常**和**Runtime异常**，Java认为Checked异常都是可以在编译阶段被处理的异常，所以它强制程序处理所有的Checked异常；而Runtime异常则无须处理。Checked异常可以提醒程序员需要处理所有可能发生的异常。

## 异常处理机制

Java的异常处理机制可以让程序具有极好的容错性，让程序更加健壮。当程序运行出现意外情况时，系统会自动生成一个Exception对象来通知程序，从而实现将“业务功能实现代码”和“错误处理代码”分离，提供更好的可读性。

### 使用try...catch捕获异常

Java异常处理机制的语法结构。

```java
try {
    // 业务实现代码
    ...
} catch (Exception e) {
    // 错误处理代码
    ...
}
```

如果执行try块里的业务逻辑代码时出现异常，系统自动生成一个异常对象，该异常对象被提交给Java运行时环境，这个过程被称为**抛出**（throw）异常。

当Java运行时环境收到异常对象时，会寻找能处理该异常对象的catch块，如果找到合适的catch块则把异常对象交给该catch块处理，这个过程称为**捕获**（catch）异常；如果Java运行时环境找不到捕获异常的catch块，则运行时环境终止，Java程序也将退出。

不管程序代码块是否处于try块中，甚至包括catch块中的代码，只要执行该代码块时出现了异常，系统总会自动生成一个异常对象。如果程序没有为这段代码定义任何的catch块，则Java运行时环境无法找到处理该异常的catch块，程序就在此退出。

### 异常类的继承体系

每个catch块都是专门用于处理该异常类及其子类的异常实例。

当Java运行时环境接收到异常对象后，会依次判断该异常对象是否是catch块后异常类或其子类的实例，如果是，Java运行时环境将调用该catch块来处理异常；否则再次拿该异常对象和下一个catch块里的异常类进行比较。

try块后的花括号（{...}）不可以省略，catch块后的花括号（{...}）也不可以省略。try块里声明的变量是代码块内局部变量，它只在try块内有效，在catch块中不能访问该变量。

Java把所有的非正常情况分为两种：**异常**（Exception）和**错误**（Error），它们都继承**Throwable**父类。

Error错误，一般是指与虚拟机相关的问题，如系统崩溃、虚拟机错误、动态链接失败等，这种错误无法恢复或不可能捕获，这将导致应用程序中断。通常应用程序无法处理这些错误，因此应用程序不应该试图使用catch块来捕获Error对象。在定义该方法时，也无须在其throws子句中声明该方法可能抛出Error及其任何子类。

Java运行时的异常处理逻辑可能有如下几种情形。

- 数组越界异常，Java运行时将调用**IndexOutOfBoundsException**对应的catch块处理异常。
- 数字格式异常，Java运行时将调用**NumberFormatException**对应的catch块处理异常。
- 算术异常（例除0异常），Java运行时将调用**AritheticException**对应的catch块处理该异常。
- 如果程序运行时出现其他异常，该异常对象总是**Exception**类或其子类的实例，Java运行时将调用Exception对应的catch块处理该异常。
- 当试图调用一个null对象的实例方法或实例变量时，就会引发**NullPointerException**异常，Java运行将会调用对应的catch块来处理该异常。

总是把对应Exception类的catch块放在最后，实际上，进行异常捕获时不仅应该把Exception类对应的catch块放在最后，而且所有父类异常的catch块都应该排在子类异常catch块的后面，即先处理小异常，再处理大异常，否则将出现编译错误。

### Java7新增的多异常捕获

在Java7以前，每个catch块只能捕获一种类型的异常；但从Java7开始，一个catch块可以捕获多种类型的异常。

使用一个catch块捕获多种类型的异常时需要注意如下两个地方。

- 捕获多种类型的异常时，多种异常类型之间用竖线（|）隔开。
- 捕获多种类型的异常时，异常变量有隐式的final修饰，因此程序不能对异常变量重新赋值。

```java
public class MultiExceptionTest {
	public static void main(String[] args) {
		try {
			int a = Integer.parseInt(args[0]);
			int b = Integer.parseInt(args[1]);
			int c = a / b;
			System.out.println("您输入的两个数相除的结果是: " + c);
		} catch(IndexOutOfBoundsException | NumberFormatException | ArithmeticException ie) {
			System.out.println("程序发生了数组越界、数字格式异常、算术异常之一");
			// 捕获多异常时，异常变量默认有final修饰
			// 所以下面代码有错
			ie = new ArithmeticException("test");
		}
	}
}
```

### 访问异常信息

如果程序需要在catch块中访问异常对象的相关信息，则可以通过catch块的后异常形参来获得。当Java运行时决定调用某个catch块来处理该异常对象时，会将异常对象赋给catch块后的异常参数，程序即可通过该参数来获得异常的相关信息。

所有的异常对象都包含了如下几个常用方法。

- `getMessage()`：返回该异常的详细描述字符串。
- `printStackTrace()`：将该异常的跟踪栈信息输出到标准错误输出。
- `printStackTrace(PrintStream s)`：将该异常的跟踪栈信息输出到指定输出流。
- `getStackTrace()`：返回该异常的跟踪栈信息。

```java
public class AccessExceptionMsg {
	public static void main(String[] args) {
		try {
			FileInputStream fis = new FileInputStream("a.txt");
		} catch (IOException ioe) {
			System.out.println(ioe.getMessage());
			ioe.printStackTrace();
		}
	}
}
```

程序将输出：

```java
a.txt (系统找不到指定的文件。)
java.io.FileNotFoundException: a.txt (系统找不到指定的文件。)
	at java.base/java.io.FileInputStream.open0(Native Method)
	at java.base/java.io.FileInputStream.open(FileInputStream.java:213)
	at java.base/java.io.FileInputStream.<init>(FileInputStream.java:155)
	at java.base/java.io.FileInputStream.<init>(FileInputStream.java:110)
	at exception_handling.mechanism.AccessExceptionMsg.main(AccessExceptionMsg.java:10)
```

### 使用finally回收资源

有些时候，程序在try块里打开了一些物理资源（例如数据库连接、网络连接和磁盘文件等），这些物理资源都必须显式回收。

Java的垃圾回收机制不会回收任何物理资源，垃圾回收机制只能回收堆内存中对象所占用的内存。

为了保证一定能回收try块中打开的物理资源，异常处理机制提供了finally块。不管try块中的代码是否出现了异常，也不管哪一个catch块被执行，甚至在try块或catch块中执行return语句，finally块总被执行。完整的Java异常处理语法结构如下：

```java
try {
    // 业务实现代码
    ...
} catch (SubExceotion e) {
    // 异常处理块1
    ...
} catch (SubException2 e) {
    // 异常处理快2
    ...
} ... finally {
    // 资源回收
    ...
}
```

异常处理语法结构中只有try是必需的，catch块和fianlly块都是可选的，但catch块和finally块至少出现其中之一，也可以同时出现；可以有多个catch块，捕获父类异常的catch块必须位于捕获子类异常的后面；但不能只有try块，既没有catch块，也没有finally块；多个catch块必须位于try块之后，finally块必须位于所有的catch块之后。

除非在try块、catch块中调用了退出虚拟机的方法（`System.exit()`），否则不管在try块、catch块执行怎样的代码，出现怎样的情况，异常处理的finally块总会被执行。

在通常情况下，不要在finally块中使用如return或throw等导致方法终止的语句，一旦在finally块中使用了return或throw语句，将会导致try块、catch块中的return、throw语句失效。

当Java程序执行try块、catch块时遇到了return或throws语句，这两个语句都会导致该方法立即结束，但是系统执行这两个语句并不会结束该方法，而是去寻找该异常处理流程中是否包含finally块，如果没有finally块，程序立即执行return或throws语句，方法终止；如果有finally块，系统立即开始执行finally块——只有当finally块执行完成后，系统才会再次跳回来执行try块、catch块里的return或throws语句；如果finally块里也使用了return或throws等导致方法终止的语句，finally块已经终止了方法，系统将不会跳回去执行try块、catch块里的任何代码。

### 异常处理的嵌套

在try块、catch块或在finally块中包含完整的异常处理流程的情形被称为异常处理的嵌套。

异常处理代码流程代码可以放在任何能放可执行性代码的地方，因此完整的异常处理流程即可放在try块里，也可放在catch块里，还可放在finally块里。

异常处理嵌套的深度没有很明确的限制，但通常没有必要使用超过两层的嵌套异常处理。

### Java9增强的自动关闭资源的try语句

Java7增强了try语句的功能——它允许在try关键字后紧跟一对圆括号，圆括号可以声明、初始化一个或多个资源，此处的资源是指那些必须在程序结束时显式关闭的资源（比如数据库连接、网络连接等），try语句在该语句结束时自动关闭这些资源。

为了保证try语句可以正常关闭资源，这些资源实现类必须实现**AutoCloseable**或**Closeable**接口，实现这两个接口就必须实现`close()`方法。

Closeable是AutoCloseable的子接口，可以被自动关闭的资源类要么实现AutoCloseable接口，要么实现Closeable接口。Closeable接口里的`close()`方法声明抛出了IOException，因此它的实现类在实现`close()`方法时只能声明抛出IOException或其子类；AutoCloseable接口里的`close()`方法声明抛出了Exception，因此它的实现类在实现`close()`方法时可以声明抛出任何异常。

自动关闭资源的try语句相当于包含了隐式的finally块（这个finally块用于关闭资源），因此这个try语句可以既没有catch块，也没有finally块。

```java
public class AutoCloseTest {
	public static void main(String[] args) throws IOException{
		try(
				// 声明、初始化两个可关闭的资源
				// try语句会自动关闭这两个资源
				BufferedReader br = new BufferedReader(new FileReader("AutoCloseTest.java"));
				PrintStream ps = new PrintStream(new FileOutputStream("a.txt"))) {
			// 使用两个资源
			System.out.println(br.readLine());
			ps.println("庄生晓梦迷蝴蝶");
		}
	}
}
```



Java7几乎把所有的“资源类”（包括文件IO的各种类、JDBC变成的Connection、Statement等接口）进行了改写，改写后资源类都实现了AutoCloseable或Closeable接口。

如果程序需要，自动关闭资源的try语句后也可以带多个catch块和一个finally块。

Java9再次增强了这种try语句，Java9要求不在try后的圆括号内声明并创建资源，只需要自动关闭的资源有final修饰或是有效的final（effectively final），Java9允许将资源变量放在try后的圆括号内。上面程序在Java9中可改写为如下形式。

```java
public class AutoCloseTest2 {
	public static void main(String[] args) throws IOException {
		// 有final修饰的资源
		final BufferedReader br = new BufferedReader(new FileReader("AutoCloseTest.java"));
		// 没有显式使用final修饰，但只要不对该变量重新赋值，该变量就是有效的final
		PrintStream ps = new PrintStream(new FileOutputStream("a.txt"));
		// 只要将两个资源放在try后的圆括号内即可
		try (br; ps) {
			// 使用两个资源
			System.out.println(br.readLine());
			ps.println("庄生晓梦迷蝴蝶");
		}
	}
}
```

## Checked异常和Runtime异常体系

Java的异常被分为两大类：**Checked异常**和**Runtime异常**（运行时异常）。所有的RuntimeException类及其子类的实例被称为Runtime异常；不是RuntimeException类及其子类的异常实例则被称为Checked异常。

Java认为Checked异常都是可以被处理（修复）的异常，所以Java程序必须显式处理Checked异常。如果程序没有处理Checked异常，该程序在编译时就会发生错误，无法通过编译。

对于Checked异常的处理方式有如下两种。

- 当前方法明确知道如何处理该异常，程序应该使用`try...catch`块来捕获该异常，然后在对应的catch块中修复该异常。
- 当前方法不知道如何处理这种异常，应该在定义该方法时声明抛出该异常。

Runtime异常则更加灵活，Runtime异常无须显式声明抛出，如果程序需要捕获Runtime异常，也可以使用`try...catch`块来实现。

### 使用throws声明抛出异常

使用**throws**声明抛出异常的思路是，当前方法不知道如何处理这种类型的异常，该异常应该由上一级调用者处理；如果main方法也不知道如何处理这种类型的异常，也可以使用throws声明抛出异常，该异常将交给JVM处理。JVM对异常的处理方法是，打印异常的跟踪栈信息，并中止程序运行。

throws声明抛出只能在方法签名中使用，throws可以声明多个异常类，多个异常类之间以逗号隔开。throws声明抛出的语法格式如下：

```java
throws ExceptionClass1, ExceptionClass2...
```

throws声明抛出的语法格式仅跟在方法签名之后，一旦使用throws语句声明抛出该异常，程序就无须使用try...catch块来捕获异常了。

如果某段代码中调用了一个带throws声明的方法，该方法抛出了Checked异常，则表明该方法希望它的调用者来处理该异常。也就是说，调用该方法时要么放在try块中显式捕获该异常，要么放在另一个带throws声明抛出的方法中。

### 方法重写时声明抛出异常的限制

使用throws声明抛出异常时有一个限制，就是方法重写时”两小“中的一条规则：子类方法声明抛出的异常类型应该的父类方法声明抛出的异常类型的子类或相同，子类方法声明抛出的异常不允许比父类方法声明抛出的异常多。

使用Checked异常至少存在如下两大不便之处。

- 对于程序中的Checked异常，Java要求必须显式捕获并处理该异常，或者显式声明抛出该异常。这样就增加了编程的复杂度。
- 如果在方法中显式声明抛出Checked异常，将会导致方法签名与异常耦合，如果该方法是重写父类的方法，则该方法抛出的异常还会受到被重写方法所抛出异常的限制。

在大部分时候推荐使用Runtime异常，而不使用Checked异常。尤其当程序需要自行抛出异常时，使用Runtime异常将更加简洁。

当使用Runtime异常时，程序无须在方法中声明抛出Checked异常，一旦发生了自定义错误，程序只管抛出Runtime异常即可。

如果程序需要在合适的地方捕获异常并对异常进行处理，则一样可以使用try...catch块来捕获Runtime异常。

使用Runtime异常是比较省事的方式，使用这种方式既可以享受”正常代码和错误处理代码分离“，”保证程序具有较好的健壮性“的优势，又可以避免因为使用Checked异常带来的编程繁琐性。

但Checked异常也有优势——Checked异常能在编译时提醒程序云代码可能存在的问题，提醒程序员必须注意处理该异常，或者声明该异常由该方法调用者来处理。

