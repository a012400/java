# 泛型

## 泛型入门

Java集合有个缺点——把一个对象“丢进”集合里之后，集合就会“忘记”这个对象的数据类型，当再次取出该对象时，该对象的编译类型就变成了Object类型（其运行时类型没变）。

### 编译时不检查类型的异常

下面代码将会看到编译时不检查类型所导致的异常。

```java
import java.util.ArrayList;
import java.util.List;

public class ListErr {

	public static void main(String[] args) {
		// 创建一个只想保存字符串的List集合
		List strList = new ArrayList();
		strList.add("十年寒窗无人问");
		strList.add("纵使相逢应不识");
		// "不小心"把一个Integer对象"丢进"了集合
		strList.add(5);
		strList.forEach(str -> System.out.println(((String) str).length()));
	}

}
```

上面程序创建了一个List集合，而且只希望该List集合保存字符串对象——但程序不能进行任何限制，上面程序将引发ClassCastException异常。

### 使用泛型

从Java5以后，Java引入了**参数化类型**（parameterized type）的概念，允许程序在创建集合时指定集合元素的类型。Java参数化类型被称为**泛型**（Generic）。

创建这种特殊集合的方法是：在集合接口 、类后增加尖括号，尖括号里放一个数据类型，即表明这个集合接口、集合类只能保存特定类型的对象。从而使集合自动记住所有集合元素的数据类型，从而无须对集合元素进行强制类型转换。

### Java9增强的”菱形“语法

在Java7以前，如果使用带泛型的接口、类定义变量，那么调用构造器创建对象时构造器的后面也必须带泛型，这显得有些多余了。例如如下两条语句。

```java
List<String> strList = new ArrayList<String>();
Map<String, Integer> scores = new HashMap<String, Integer>();
```

上面两条语句中的构造器后面的尖括号部分完全是多余的，在Java7以前这是必需的，不能省略。从Java7开始，Java允许在构造器后不需带完整的泛型信息，只要给出一对尖括号（<>）即可，Java可以推断尖括号里应该是什么泛型信息。上面两条代码可以改写为如下形式。

```java
List<String> strList = new ArrayList<>();
Map<String, Integer> scores = new HashMap<>();
```

Java9再次增强了”菱形“语法，它甚至允许在创建**匿名内部类**时使用菱形语法，Java可根据上下文来推断匿名内部类中泛型的类型。下面代码示范了在匿名内部类中使用菱形语法。

```java
interface Foo<T> {
	void test(T t);
}

public class AnnoymousDiamond {

	public static void main(String[] args) {
		// 指定Foo类中泛型为String
		Foo<String> f = new Foo<>() {
			// test()方法的参数类型为String
			public void test(String t) {
				System.out.println("test方法的t参数为: " + t);
			}
		};
		// 使用泛型通配符，此时相当于通配符的上限为Object
		Foo<?> fo = new Foo<>() {
			// tes()方法的参数类型为Object
			public void test(Object t) {
				System.out.println("test方法的Object参数为: " + t);
			}

		};
		// 使用泛型通配符，通配符的上限为Number
		Foo<? extends Number> fn = new Foo<>() {
			// 此时test()方法的参数类型为Number
			public void test(Number t) {
				System.out.println("test方法的Number参数为: " + t);
			}
		};
	}

}
```

上面的代码定义了带泛型声明的接口。

## 深入泛型

所谓泛型，就是允许在定义类、接口、方法时使用类型的形参，这个**类型形参**（或叫泛型）将在声明变量、创建对象、调用方法时动态地指定（即传入实际的类型参数，也可称为**类型实参**）。Java5改写了集合框架中的全部接口，为这些接口、类增加了泛型支持，从而可以在声明集合变量、创建集合对象时传入类型实参。

### 定义泛型接口、类

下面是Java5改写后List接口、Iterator接口、Map的代码片段。

```java
// 定义接口时制定了一个泛型形参，该形参名为E
public interface List<E> {
    // 在该接口里，E可作为类型使用
    // 下面方法可以使用E作为参数类型
    void add(E x);
    Iterator<E> iterator();
    ...
}
// 定义接口时指定了一个泛型形参，该形参名为E
public interface Iterator<E> {
    // 在该接口里E完全可作为类型使用
    E next();
    boolean hasNext();
    ...
}
// 定义接口时指定了一个泛型形参，该形参名为E
public interface Map<K, V> {
    // 在该接口里K、V完全可作为类型使用
    Set<K, V> keySet();
    V put(K key, V value);
    ...
}
```

允许在定义接口、类时声明**泛型形参**，泛型形参在整个接口、类体内可当成类型使用，几乎所有可使用普通类型的地方都可以使用这种泛型形参。

可以为任何类、接口增加泛型声明，并不是只有集合类才可以使用泛型声明。

### 从泛型类派生子类

当创建了带泛型声明的接口、父类之后，可以为该接口创建实现类，或从该父类派生子类，当使用这些接口、父类时不能再包含泛型形参。

方法中的形参代表变量、常量、表达式等数据。定义方法时可以声明数据形参，调用方法时必须为这些数据形参传入实际的数据；与此类似的是，定义类、接口、方法时可以声明泛型形参，使用类、接口、方法时应该为泛型形参传入实际的类型。

如果想从Apple类派生一个子类，如下代码。

```java
// 使用Apple类时，为T形参传入String类型
public class A extends Apple<String>
```

调用方法时必须为所有的数据形参传入参数值，与调用方法不同的是，使用类、接口时也可以不为泛型形参传入实际的类型参数，下面代码也是正确的。

```java
// 使用Apple类时，没有为T形参传入实际的类型参数
public class A extends Apple
```

像这种使用Apple类时省略泛型的形式被称为**原始类型**（raw type）。

如果使用原始类型的形式继承父类，Java编译器可能发出警告：使用了未经检查或不安全的操作——这就是泛型检查的警告，如果希望看到该警告提示的更详细信息，则可以通过为javac命令增加`-Xlint:unchecked`选项来实现。

### 并不存在泛型类

当一个类使用了泛型，系统并没有为该类生成新的class文件，而且也不会将该类当成新类来处理。不管泛型的实际类型参数是什么，它们在运行时总有同样的类。

不管泛型形参传入哪一种类型实参，对于Java来说，它们依然被当成同一个类处理，在内存中也只占用一块，因此在静态方法、静态初始化块或者静态变量的声明和初始化中**不允许**使用泛型形参。下面程序演示了这种错误。

```java
public class R<T> {
    // 下面代码错误，不能在静态变量声明中使用泛型形参
    static T info;
    T age;
    public void foo(T msg) {}
    // 下面代码错误，不能在静态方法声明中使用泛型形参
    public static void bar(T msg) {}
```

由于系统中并不会真正生成泛型类，所以instanceof运算符后面不能使用泛型类。下面代码是错误的。

```java
Collection<String> cs = new ArrayList<>();
// 下面代码编译时引发错误：instanceof运算符后不能使用泛型
if (cs instanceof ArrayList<String>) {
    ...
}
```

## 类型通配符

当使用一个泛型类时（包括声明变量和创建对象两种情况），都应该为这个泛型类传入一个类型实参。如果没有传入类型实际参数，编译器就会提出泛型警告。

如果Foo是Bar的一个子类型（子类或者子接口），而G是具有泛型声明的类或接口，G<Foo>并不是G<Bar>的子类型。

在数组中，程序可以直接把一个Integer[]数组赋给一个Number[]变量。如果试图把一个Double对象保存到该Number[]数组中，编译可以通过，但在运行时抛出ArrayStoreException异常。

Java在泛型设计时进行了改进，不再允许把List<Integer>对象赋值给List<Number>变量。

Java泛型设计原则是，只要代码在编译时没有出现警告，就不会遇到运行时ClassCastException异常。

数组和泛型有所不同，假设Foo是Bar的一个子类型（子类或者子接口），那么Foo[]依然是Bar[]的子类型；但G<Foo>不是G<Bar>的子类型。Foo[]自动向上转型为Bar[]的方式被称为**型变**。Java数组支持型变，但Java集合并不支持型变。

