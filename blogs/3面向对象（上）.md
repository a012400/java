# 面向对象（上）

## 类和对象

### 定义类

```java
[修饰符] class 类名 {
	// 初始化代码块
    // 构造器
    // 成员变量
    // 方法
}
```

#### 定义成员变量

`[修饰符] 类型 成员变量名 [= 默认值];`

- 修饰符
  - `public`
  - `protected`
  - `private`
  - `static`
  - `final`

#### 定义方法

```java
[修饰符] 返回值类型 方法名 ( 形参列表 ) {
    // 方法体
};
```

- 修饰符
  - `public`
  - `protected`
  - `private`
  - `static`
  - `final`
  - `abstract`

#### 定义构造器
```java
[修饰符] 构造器名 ( 形参列表 ) {
    // 构造器体
};
```

- 修饰符
  - `public`
  - `protected`
  - `private`
- 构造器名：必须和类名相同

### 对象、引用和指针

- 引用存储在栈内存
- 对象存储在堆内存
- 垃圾回收机制
  - 当堆内存的对象没有任何引用变量指向时，java将自动释放该对象的内存
- `this`
  - 构造器中引用该构造器正在初始化的对象
  - 在方法中引用调用该方法的对象
  - 在方法中this作为返回值返回调用该方法的对象，可以连续调用方法

### 方法

- 形参参数可变的方法
  - `type... variable;`
    - 多个参数值被当成数组传入
  - `type[] variable;`
    - 参数传入时必须是一个数组的引用类型变量
- 递归方法
- 方法重载
  - 确定一个方法的三要素
    - 调用者
    - 方法名
    - 形参列表
  - 要求：同一个类中方法名相同，参数列表不同

## 成员变量和局部变量

### 成员变量

- 实例变量（不以static修饰）
- 类变量（以static修饰）

### 局部变量

- 形参
- 方法局部变量
- 代码块局部变量

## 隐藏和封装

### 封装（encapsulation）

访问控制符

- `private` 当前类访问权限
- `default` 默认：包访问权限
- `protected` 子类访问权限
- `public` 公共访问权限
  - 源文件名必须和类名相同

package、import、import static

- package
  - `package packageName;`
    - 放在第一行
  - 编译、运行
    - `javac -d . fileName.java`
    - `java pakcageName.className`
  - 调用构造器时也需要加上包前缀
  - `package.subPackage.ClassName  variable  =  new  package.subPackage.ClassName()；`
- import
  - 向某个java文件导入指定包层次下的某个类或全部类
  - 导入单个类：
`import  package.subPackage...ClassName;`
  - 导入全部类：
`import  package.subPackage...*;`
- import  static
  - 导入指定类的单个或全部的静态成员变量、方法
    - 导入指定类的单个静态成员变量、方法
    - `import  static  package.subPackage...ClassName.fieldName | methodName;`
  - 导入指定类的全部静态成员变量、方法
    - `import  static  package.subPackage...ClassName.*;`

### Java常用包

- `java.lang` ：Java的核心类，系统自动导入
- `java.util` ：大量的工具类/接口和集合框架类/接口
- `java.net` ：网络编程相关的类/接口
- `java.io` ：输入/输出的相关的类/接口
- `java.text` ：格式化相关的类
- `java.sql` ：进行JDBC数据库编程的相关类/接口
- `java.awt` ：抽象窗口工具集的相关类/接口，主要用于构建图形界面（GUI）程序
- `java.swing` ：swing图形用户界面编程的相关类/接口，用于构建平台无关的图形界面（GUI）程序

## 构造器

### 使用构造器执行初始化

构造器是一个特殊的方法，这个方法用于创建实例时执行初始化

### 构造器重载

使用this在一个构造器中调用另一个构造器

`this(形参列表);`

## 继承

```java
[修饰符]  class subClass  extends  superClass{
    // 类体
}
```

### 重写(override)父类的方法

- 规则：方法名相同、形参列表相同、子类方法返回值类型应比父类更小或相等、子类方法声明抛出的异常类应比父类更小或相等、子类方法的访问权限应比父类方法更大或相等
- 覆盖方法和被覆盖方法要么都是类方法，要么都是实例方法
- 调用父类被覆盖的方法
  - 实例方法：`super.被覆盖的实例方法()`
  - 类方法：`父类名.被覆盖的类方法()`

### 调用父类构造器

- `super(形参列表)`
- 子类总会调用父类的构造器

## 多态

引用变量两种类型：编译时类型、运行时类型

引用变量在编译阶段只能调用其编译时类型的所具有的方法，但运行时则执行它运行时类型所具有的方法

子类是特殊的父类，把一个子类对象赋值给父类的引用变量，系统自动完成向上转型

### 强制类型转换

- 为了程序健壮性，在强制类型转换前先使用`instanceof`运算符判断是否可以转换
- `instanceof`运算符
  - 判断一个对象是否为一个类的实例

## 继承与组合

- 继承
  - 继承破坏了父类的封装性，子类可以直接访问父类的内部信息，造成了子类和父类的耦合，可能会出现子类恶意篡改父类的方法
  - 父类、子类、其他类
    - 父类中那些仅为辅助其他的工具方法，应该使用private访问控制符，不让子类访问改方法
    - 父类中的方法需要被外部类调用，必须使用public修饰，但又不希望子类重写该方法，可以使用final修饰符
    - 如果希望父类的某个方法被子类重写，但不希望被其他类自由访问，使用protected来修饰
    - 不要在父类构造器中调用被子类重写的方法
- 在父类构造器中调用了被重写的方法，在new子类对象的时候，会自动调用父类构造器，在父类构造器中调用的方法时子类的，会引发一些错误
- 如果仅仅需要复用一个类，可以用组合

### 组合

- 把旧类对象作为新类的成员变量组合进来
- 继承表达的是一种“是（is-a）”的关系，而组合表达的是“有（has-a）”的关系

## 初始化块

初始化块是类的第4种成员变量，一个类里可以有多个初始化块，先定义的先执行

```java
[修饰符] {
    // 初始化代码
}
```

修饰符只能是`static`

- 初始化块在创建对象时执行，然后执行构造器
- 编译java类后，会将初始化块代码还原到每个构造器中，放在最前面
- 静态初始化块，使用`static`修饰的初始化块
- 静态初始化块实在类初始化阶段执行，而不是在创建对象时才执行
  - 静态成员不能访问非静态成员，即不能对实例变量进行初始化

### 执行顺序

- 类初始化阶段
  - 最顶层父类的静态初始化块->依次向下->当前类的初始化块
- 对象初始化阶段
  - 最顶层父类的初始化块->最顶层父类的构造器->依次向下->当前类初始化块、当前类构造器
